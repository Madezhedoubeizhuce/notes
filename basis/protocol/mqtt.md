# MQTT控制报文格式

## MQTT控制报文的结构

MQTT控制报文由三部分组成：

<table style="text-align:center">
  <tr>
    <td align="center">Fixed header</td>
    <td >固定报头，所有控制报文都包含</td>
  </tr>
  <tr>
    <td align="center">Variable header</td>
    <td>可变报头，部分控制报文包含</td>
  </tr>
  <tr>
    <td align="center">Payload</td>
    <td>有效载荷，部分控制报文包含</td>
  </tr>
</table>

##  固定报头 Fixed header

每个MQTT控制报文都包含一个固定报头。

<table style="text-align:center">
  <tr>
    <td align="center"><strong>Bit</strong></td>
    <td align="center"><strong>7</strong></td>
    <td align="center"><strong>6</strong></td>
    <td align="center"><strong>5</strong></td>
    <td align="center"><strong>4</strong></td>
    <td align="center"><strong>3</strong></td>
    <td align="center"><strong>2</strong></td>
    <td align="center"><strong>1</strong></td>
    <td align="center"><strong>0</strong></td>
  </tr>
  <tr>
    <td>byte 1</td>
    <td colspan="4" align="center">MQTT控制报文的类型</td>
    <td colspan="4" align="center">用于指定控制报文类型的标志位</td>
  </tr>
  <tr>
    <td>byte 2...</td>
    <td colspan="8" align="center">剩余长度</td>
  </tr>
</table>

### MQTT控制报文的类型

表示为4位无符号值，这些值的定义见下表：

| **名字**    | **值** | **报文流动方向** | **描述**                            |
| ----------- | ------ | ---------------- | ----------------------------------- |
| Reserved    | 0      | 禁止             | 保留                                |
| CONNECT     | 1      | 客户端到服务端   | 客户端请求连接服务端                |
| CONNACK     | 2      | 服务端到客户端   | 连接报文确认                        |
| PUBLISH     | 3      | 两个方向都允许   | 发布消息                            |
| PUBACK      | 4      | 两个方向都允许   | QoS 1消息发布收到确认               |
| PUBREC      | 5      | 两个方向都允许   | 发布收到（保证交付第一步）          |
| PUBREL      | 6      | 两个方向都允许   | 发布释放（保证交付第二步）          |
| PUBCOMP     | 7      | 两个方向都允许   | QoS 2消息发布完成（保证交互第三步） |
| SUBSCRIBE   | 8      | 客户端到服务端   | 客户端订阅请求                      |
| SUBACK      | 9      | 服务端到客户端   | 订阅请求报文确认                    |
| UNSUBSCRIBE | 10     | 客户端到服务端   | 客户端取消订阅请求                  |
| UNSUBACK    | 11     | 服务端到客户端   | 取消订阅报文确认                    |
| PINGREQ     | 12     | 客户端到服务端   | 心跳请求                            |
| PINGRESP    | 13     | 服务端到客户端   | 心跳响应                            |
| DISCONNECT  | 14     | 客户端到服务端   | 客户端断开连接                      |
| Reserved    | 15     | 禁止             | 保留                                |

### 标志 Flags

固定报头第1个字节的剩余的4位 [3-0]包含每个MQTT控制报文类型特定的标志，见下表。表格 2.2中任何标记为“保留”的标志位，都是保留给以后使用的，**必须**设置为表格中列出的值 。如果收到非法的标志，接收者**必须**关闭网络连接。

| **控制报文** | **固定报头标志**   | **Bit 3** | **Bit 2** | **Bit 1** | **Bit 0** |
| ------------ | ------------------ | --------- | --------- | --------- | --------- |
| CONNECT      | Reserved           | 0         | 0         | 0         | 0         |
| CONNACK      | Reserved           | 0         | 0         | 0         | 0         |
| PUBLISH      | Used in MQTT 3.1.1 | DUP1      | QoS2      | QoS2      | RETAIN3   |
| PUBACK       | Reserved           | 0         | 0         | 0         | 0         |
| PUBREC       | Reserved           | 0         | 0         | 0         | 0         |
| PUBREL       | Reserved           | 0         | 0         | 1         | 0         |
| PUBCOMP      | Reserved           | 0         | 0         | 0         | 0         |
| SUBSCRIBE    | Reserved           | 0         | 0         | 1         | 0         |
| SUBACK       | Reserved           | 0         | 0         | 0         | 0         |
| UNSUBSCRIBE  | Reserved           | 0         | 0         | 1         | 0         |
| UNSUBACK     | Reserved           | 0         | 0         | 0         | 0         |
| PINGREQ      | Reserved           | 0         | 0         | 0         | 0         |
| PINGRESP     | Reserved           | 0         | 0         | 0         | 0         |
| DISCONNECT   | Reserved           | 0         | 0         | 0         | 0         |

- DUP1 =控制报文的重复分发标志
- QoS2 = PUBLISH报文的服务质量等级
- RETAIN3 = PUBLISH报文的保留标志

### 剩余长度

剩余长度（Remaining Length）表示当前报文剩余部分的字节数，包括可变报头和负载的数据。剩余长度不包括用于编码剩余长度字段本身的字节数。

## 可变报头

某些MQTT控制报文包含一个可变报头部分。它在固定报头和负载之间。可变报头的内容根据报文类型的不同而不同。可变报头的报文标识符（Packet Identifier）字段存在于在多个类型的报文里。

### 报文标识符

| **Bit** | **7** - **0**  |
| ------- | -------------- |
| byte 1  | 报文标识符 MSB |
| byte 2  | 报文标识符 LSB |

需要报文标识符的控制报文：

| **控制报文** | **报文标识符字段**  |
| ------------ | ------------------- |
| CONNECT      | 不需要              |
| CONNACK      | 不需要              |
| PUBLISH      | 需要（如果QoS > 0） |
| PUBACK       | 需要                |
| PUBREC       | 需要                |
| PUBREL       | 需要                |
| PUBCOMP      | 需要                |
| SUBSCRIBE    | 需要                |
| SUBACK       | 需要                |
| UNSUBSCRIBE  | 需要                |
| UNSUBACK     | 需要                |
| PINGREQ      | 不需要              |
| PINGRESP     | 不需要              |
| DISCONNECT   | 不需要              |

客户端和服务端彼此独立地分配报文标识符。因此，客户端服务端组合使用相同的报文标识符可以实现并发的消息交换。

## 有效载荷 Payload

某些MQTT控制报文在报文的最后部分包含一个有效载荷，这将在第三章论述。对于PUBLISH来说有效载荷就是应用消息。

需要有效载荷的控制报文：

| **控制报文** | **有效载荷** |
| ------------ | ------------ |
| CONNECT      | 需要         |
| CONNACK      | 不需要       |
| PUBLISH      | 可选         |
| PUBACK       | 不需要       |
| PUBREC       | 不需要       |
| PUBREL       | 不需要       |
| PUBCOMP      | 不需要       |
| SUBSCRIBE    | 需要         |
| SUBACK       | 需要         |
| UNSUBSCRIBE  | 需要         |
| UNSUBACK     | 不需要       |
| PINGREQ      | 不需要       |
| PINGRESP     | 不需要       |
| DISCONNECT   | 不需要       |

# MQTT控制报文

## CONNECT – 连接服务端

### 连接标志 Connect Flags

#### 清理会话 Clean Session

这个二进制位指定了会话状态的处理方式。

客户端和服务端可以保存会话状态，以支持跨网络连接的可靠消息传输。这个标志位用于控制会话状态的生存时间。

如果清理会话（CleanSession）标志被设置为0，服务端**必须**基于当前会话（使用客户端标识符识别）的状态恢复与客户端的通信。如果没有与这个客户端标识符关联的会话，服务端**必须**创建一个新的会话。在连接断开之后，当连接断开后，客户端和服务端**必须**保存会话信息 \[MQTT-3.1.2-4\]。当清理会话标志为0的会话连接断开之后，服务端**必须**将之后的QoS 1和QoS 2级别的消息保存为会话状态的一部分，如果这些消息匹配断开连接时客户端的任何订阅 \[[MQTT-3](https://tools.oasis-open.org/issues/browse/MQTT-3).1.2-5\]。服务端也**可以**保存满足相同条件的QoS 0级别的消息。

如果清理会话（CleanSession）标志被设置为1，客户端和服务端**必须**丢弃之前的任何会话并开始一个新的会话。会话仅持续和网络连接同样长的时间。与这个会话关联的状态数据**不能**被任何之后的会话重用 \[MQTT-3.1.2-6\]。

客户端的会话状态包括：

-   已经发送给服务端，但是还没有完成确认的QoS 1和QoS 2级别的消息
-   已从服务端接收，但是还没有完成确认的QoS 2级别的消息。

服务端的会话状态包括：

-   会话是否存在，即使会话状态的其它部分都是空。
-   客户端的订阅信息。
-   已经发送给客户端，但是还没有完成确认的QoS 1和QoS 2级别的消息。
-   即将传输给客户端的QoS 1和QoS 2级别的消息。
-   已从客户端接收，但是还没有完成确认的QoS 2级别的消息。
-   可选，准备发送给客户端的QoS 0级别的消息。 

保留消息不是服务端会话状态的一部分，会话终止时**不能**删除保留消息 \[MQTT-3.1.2.7\]。

### 有效载荷 Payload

#### 客户端标识符 Client Identifier

服务端使用客户端标识符 (ClientId) 识别客户端。连接服务端的每个客户端都有唯一的客户端标识符（ClientId）。客户端和服务端都必须使用ClientId识别两者之间的MQTT会话相关的状态 \[MQTT-3.1.3-2\]。

# 操作行为

## 状态存储 Storing state

为了提供服务质量保证，客户端和服务端有必要存储会话状态。在整个会话期间，客户端和服务端都**必须**存储会话状态 \[MQTT-4.1.0-1\]。会话**必须**至少持续和它的活跃网络连接同样长的时间 \[MQTT-4.1.0-2\]。

服务端的保留消息不是会话状态的组成部分。服务端**应该**保留那种消息直到客户端删除它。

## 网络连接 Network Connections

MQTT协议要求基础传输层能够提供有序的、可靠的、双向传输（从客户端到服务端 和从服务端到客户端）的字节流。

## 服务质量等级和协议流程 QoS

MQTT按照这里定义的服务质量 (QoS) 等级分发应用消息。分发协议是对称的，在下面的描述中，客户端和服务端既可以是发送者也可以是接收者。分发协议关注的是从单个发送者到单个接收者的应用消息。服务端分发应用消息给多个客户端时，每个客户端独立处理。分发给客户端的出站应用消息和入站应用消息的QoS等级可能是不同的。

下面的非规范流程图展示了可能的实现方法。

### QoS 0:最多分发一次

消息的分发依赖于底层网络的能力。接收者不会发送响应，发送者也不会重试。消息可能送达一次也可能根本没送达。

对于QoS 0的分发协议，发送者

-   **必须**发送QoS等于0，DUP等于0的PUBLISH报文 \[MQTT-4.3.1-1\]。

对于QoS 0的分发协议，接收者

-   接受PUBLISH报文时同时接受消息的所有权。

##### 图例 4.1 – QoS 0协议流程图，非规范示例

| **发送者动作**            | **控制报文**   | **接收者动作**                       |
| ------------------------- | -------------- | ------------------------------------ |
| PUBLISH 报文 QoS 0, DUP=0 |                |                                      |
|                           | ----------&gt; |                                      |
|                           |                | 分发应用消息给适当的后续接收者（们） |

### QoS 1: 至少分发一次

服务质量确保消息至少送达一次。QoS 1的PUBLISH报文的可变报头中包含一个报文标识符，需要PUBACK报文确认。2.3.1节提供了有关报文标识符的更多信息。

对于QoS 1的分发协议，发送者

-   每次发送新的应用消息都**必须**分配一个未使用的报文标识符。
-   发送的PUBLISH报文**必须**包含报文标识符且QoS等于1，DUP等于0。
-   **必须**将这个PUBLISH报文看作是 *未确认的* ，直到从接收者那收到对应的PUBACK报文。4.4节有一个关于未确认消息的讨论。

> \[MQTT-4.3.2-1\].
>
> 一旦发送者收到PUBACK报文，这个报文标识符就可以重用。

注意：允许发送者在等待确认时使用不同的报文标识符发送后续的PUBLISH报文。

对于QoS 1的分发协议，接收者

-   响应的PUBACK报文**必须**包含一个报文标识符，这个标识符来自接收到的、已经接受所有权的PUBLISH报文。
-   发送了PUBACK报文之后，接收者必须将任何包含相同报文标识符的入站PUBLISH报文当作一个新的消息，并忽略它的DUP标志的值。

> \[MQTT-4.3.2-2\].

##### 图例 4.2 – QoS 1协议流程图，非规范示例

| **发送者动作**                             | **控制报文**   | **接收者动作**                     |
| ------------------------------------------ | -------------- | ---------------------------------- |
| 存储消息                                   |                |                                    |
| 发送PUBLISH报文 QoS=1, DUP=0，带报文标识符 | ----------&gt; |                                    |
|                                            |                | 开始应用消息的后续分发<sup>1</sup> |
|                                            | &lt;---------- | 发送PUBACK报文，带报文标识符       |
| 丢弃消息                                   |                |                                    |

> <sup>1</sup>不要求接收者在发送PUBACK之前完整分发应用消息。原来的发送者收到PUBACK报文之后，应用消息的所有权就会转移给这个接收者。

### QoS 2: 仅分发一次

这是最高等级的服务质量，消息丢失和重复都是不可接受的。使用这个服务质量等级会有额外的开销。

QoS 2的消息可变报头中有报文标识符。2.3.1节提供了有关报文标识符的更多信息。QoS 2的PUBLISH报文的接收者使用一个两步确认过程来确认收到。

对于QoS 2的分发协议，发送者

-   必须给要发送的新应用消息分配一个未使用的报文标识符。
-   发送的PUBLISH报文**必须**包含报文标识符且报文的QoS等于2,，DUP等于0。
-   **必须**将这个PUBLISH报文看作是 *未确认的* ，直到从接收者那收到对应的PUBREC报文。4.4节有一个关于未确认消息的讨论。
-   收到PUBREC报文后**必须**发送一个PUBREL报文。PUBREL报文必须包含与原始PUBLISH报文相同的报文标识符。
-   **必须**将这个PUBREL报文看作是 *未确认的* ，直到从接收者那收到对应的PUBCOMP报文。
-   一旦发送了对应的PUBREL报文就**不能**重发这个PUBLISH报文。

\[MQTT-4.3.3-1\].

> 一旦发送者收到PUBCOMP报文，这个报文标识符就可以重用。

注意：允许发送者在等待确认时使用不同的报文标识符发送后续的PUBLISH报文。

对于QoS 2的分发协议，接收者

-   响应的PUBREC报文**必须**包含报文标识符，这个标识符来自接收到的、已经接受所有权的PUBLISH报文。
-   在收到对应的PUBREL报文之前，接收者**必须**发送PUBREC报文确认任何后续的具有相同标识符的PUBLISH报文。 在这种情况下，它**不能**重复分发消息给任何后续的接收者。
-   响应PUBREL报文的PUBCOMP报文**必须**包含与PUBREL报文相同的标识符。
-   发送PUBCOMP报文之后，接收者必须将包含相同报文标识符的任何后续PUBLISH报文当作一个新的发布。

\[MQTT-4.3.3-2\].

##### 图例 4.3 – QoS 2协议流程图，非规范示例

| **发送者动作**                              | **控制报文**   | **接收者动作**                                               |
| ------------------------------------------- | -------------- | ------------------------------------------------------------ |
| 存储消息                                    |                |                                                              |
| 发送PUBLISH报文，QoS=2, DUP=0，带报文标识符 |                |                                                              |
|                                             | ----------&gt; |                                                              |
|                                             |                | 方法A：存储消息，或方法B：存储报文标识符，然后开始向前分发这个应用消息<sup>1</sup>。 |
|                                             |                | 发送PUBREC报文，带报文标识符。                               |
|                                             | &lt;---------- |                                                              |
| 丢弃消息，存储PUBREC中的报文标识符          |                |                                                              |
| 发送PUBREL报文，带报文标识符                |                |                                                              |
|                                             | ----------&gt; |                                                              |
|                                             |                | 方法A：开始向前分发应用消息<sup>1</sup>然后丢弃消息 或方法B：丢弃报文标识符 |
|                                             |                | 发送PUBCOMP报文，带报文标识符                                |
|                                             | &lt;---------- |                                                              |
| 丢弃已保存的状态                            |                |                                                              |

> <sup>1</sup> 不要求接收者在发送PUBREC或PUBCOMP之前完整分发应用消息。原来的发送者收到PUBREC报文之后，应用消息的所有权就会转移给这个接收者。
>
> [图例 4.3 – QoS 2协议流程图，非规范示例](#_Figure_4.3_–) 展示了接收者对QoS 2等级消息的两种处理方法。他们的区别是消息什么时候可以开始分发。实现者可以决定使用哪种方法。只要实现者只选择了一种方法，就不会影响QoS流程的可靠性。

## 消息分发重试 Message delivery retry

客户端设置清理会话（CleanSession）标志为0重连时，客户端和服务端**必须**使用原始的报文标识符重发任何未确认的PUBLISH报文（如果QoS&gt;0）和PUBREL报文  \[MQTT-4.4.0-1\]。这是唯一**要求**客户端或服务端重发消息的情况。

> **非规范评注**
>
> 控制报文的重发曾经需要克服某些陈旧TCP网络上的数据丢失问题。部署在那些环境中的MQTT 3.1.1实现可能仍然需要关注这个问题。

## 主题名和主题过滤器 Topic Names and Topic Filters

### 主题通配符 Topic wildcards

主题层级（topic level）分隔符用于将结构化引入主题名。如果存在分隔符，它将主题名分割为多个*主题层级 topic level* 。

订阅的主题过滤器可以包含特殊的通配符，允许你一次订阅多个主题。

主题过滤器中可以使用通配符，但是主题名**不能**使用通配符 \[MQTT-4.7.1-1\]。

#### 主题层级分隔符 Topic level separator

斜杠（‘/’ U+002F）用于分割主题的每个层级，为主题名提供一个分层结构。当客户端订阅指定的主题过滤器包含两种通配符时，主题层级分隔符就很有用了。主题层级分隔符可以出现在主题过滤器或主题名字的任何位置。相邻的主题层次分隔符表示一个零长度的主题层级。

#### 多层通配符 Multi-level wildcard

数字标志（‘\#’ U+0023）是用于匹配主题中任意层级的通配符。多层通配符表示它的父级和任意数量的子层级。多层通配符必须位于它自己的层级或者跟在主题层级分隔符后面。不管哪种情况，它都**必须**是主题过滤器的最后一个字符 \[MQTT-4.7.1-2\]。

> **非规范评注**
>
> 例如，如果客户端订阅主题 “sport/tennis/player1/\#”，它会收到使用下列主题名发布的消息：

-   “sport/tennis/player1”
-   “sport/tennis/player1/ranking”
-   “sport/tennis/player1/score/wimbledon”

> **非规范评注**

-   “sport/\#”也匹配单独的 “sport” ，因为 \# 包括它的父级。
-   “\#”是有效的，会收到所有的应用消息。
-   “sport/tennis/\#”也是有效的。
-   “sport/tennis\#”是无效的。
-   “sport/tennis/\#/ranking”是无效的。

#### 单层通配符

加号 (‘+’ U+002B) 是只能用于单个主题层级匹配的通配符。

在主题过滤器的任意层级都可以使用单层通配符，包括第一个和最后一个层级。然而它**必须**占据过滤器的整个层级 \[MQTT-4.7.1-3\]。可以在主题过滤器中的多个层级中使用它，也可以和多层通配符一起使用。

> **非规范评注**
>
> 例如， “sport/tennis/+” 匹配 “sport/tennis/player1” 和 “sport/tennis/player2” ，但是不匹配 “sport/tennis/player1/ranking” 。同时，由于单层通配符只能匹配一个层级， “sport/+” 不匹配 “sport” 但是却匹配 “sport/”。
>
> **非规范评注**

-   “+” 是有效的。
-   “+/tennis/\#” 是有效的。
-   “sport+” 是无效的。
-   “sport/+/player1” 也是有效的。
-   “/finance” 匹配 “+/+” 和 “/+” ，但是不匹配 “+”。

### 以\$开头的主题 Topics beginning with \$

服务端**不能**将 $ 字符开头的主题名匹配通配符 (\#或+) 开头的主题过滤器 \[MQTT-4.7.2-1\]。服务端应该阻止客户端使用这种主题名与其它客户端交换消息。服务端实现可以将 $ 开头的主题名用作其他目的。

> **非规范评注**

-   $SYS/ 被广泛用作包含服务器特定信息或控制接口的主题的前缀。
-   应用不能使用 $ 字符开头的主题。

> **非规范评注**

-   订阅 “\#” 的客户端不会收到任何发布到以 “$” 开头主题的消息。
-   订阅 “+/monitor/Clients” 的客户端不会收到任何发布到 “$SYS/monitor/Clients” 的消息。
-   订阅 “$SYS/\#” 的客户端会收到发布到以 “$SYS/” 开头主题的消息。
-   订阅 “$SYS/monitor/+” 的客户端会收到发布到 “$SYS/monitor/Clients” 主题的消息。
-   如果客户端想同时接受以 “$SYS/” 开头主题的消息和不以 $ 开头主题的消息，它需要同时订阅 “\#” 和 ““$SYS/\#”。

### 主题语义和用法 Topic semantic and usage

主题名和主题过滤器必须符合下列规则：

-   所有的主题名和主题过滤器**必须**至少包含一个字符 \[MQTT-4.7.3-1\]。
-   主题名和主题过滤器是区分大小写的。
-   主题名和主题过滤器可以包含空格。
-   主题名或主题过滤器以前置或后置斜杠 “/” 区分。
-   只包含斜杠 “/” 的主题名或主题过滤器是合法的。
-   主题名和主题过滤器**不能**包含空字符 (Unicode U+0000) \[[Unicode](#Unicode)\] \[MQTT-4.7.3-2\]。
-   主题名和主题过滤器是UTF-8编码字符串，它们**不能**超过65535字节 \[MQTT-4.7.3-3\]。见 1.5.3节。

除了不能超过UTF-编码字符串的长度限制之外，主题名或主题过滤器的层级数量没有其它限制。

匹配订阅时，服务端**不能**对主题名或主题过滤器执行任何规范化（normalization）处理，不能修改或替换任何未识别的字符 \[MQTT-4.7.3-4\]。主题过滤器中的每个非通配符层级需要逐字符匹配主题名中对应的层级才算匹配成功。

> **非规范评注**
>
> 使用UTF-8编码规则意味着，主题过滤器和主题名的比较可以通过比较编码后的UTF-8字节或解码后的Unicode字符。
>
> **非规范评注**

-   “ACCOUNTS” 和 “Accounts” 是不同的主题名。
-   “Accounts payable” 是合法的主题名
-   “/finance” 和 “finance” 是不同的。

如果订阅的主题过滤器与消息的主题名匹配，应用消息会被发送给每一个匹配的客户端订阅。主题可能是管理员在服务端预先定义好的，也可能是服务端收到第一个订阅或使用那个主题名的应用消息时动态添加的。服务端也可以使用一个安全组件有选择地授权客户端使用某个主题资源