# 算法基础
## 循环不变式
循环不变式用于辅助理解算法正确性，必须证明三条性质：
1. **初始化**：循环第一次迭代之前，它为真。
2. **保持**：如果某次迭代之前它为真，那么下次迭代之前它仍为真。
3. **终止**：在循环终止时，不变式为我们提供一个有用的性质，改性质有助于证明算法是正确的。

## 伪代码
1. 缩进表示块结构。
2. 循环结构：while、for与repeat-until，条件结构if-else。退出循环后，循环计数器保持其值。to：计数器递增，downto：计数器递减，by：计数器改变值的大小。
3. “//”表示注释。
4. 多重赋值表达式：i=j=e，将e的值赋值给i和j。
5. 变量是局部的，无显示说明，不适用全局变量。
6. 数组元素通过“数组名[下标]”的形式访问。
7. 复合数据被组织为对象，对象由属性组成。|通过在对象名后面跟一个点再跟属性名来访问属性。指针：表示数组或对象的变量。属性记号可以“串联”。不指向任何对象的指针记为NIL。
8. 按值传递，被调用过程接受参数自身的副本。
9. return语句立即将控制返回到调用过程的调用点。
10. 布尔运算符“and”和“or”都是短路的。
11. 关键字error表示出现错误。

## 分析算法
- **RAM模型**：指令一条接一条执行，没有并发操作。
- **输入规模**
- **运行时间**：执行特定输入生的基本步数。假定执行每行伪代码需要常量时间ci.
- 最坏情况和平均情况

# 设计算法
## 分治法
1. **分解**原问题为若干子问题，这些子问题是原问题规模较小的实例。
2. **解决**这些子问题，递归求解各子问题。当子问题规模足够小，直接求解
3. **合并**这些子问题的解为原问题的解
### 归并排序
### 分析分治算法
#### 递归树
1. 每个结点表示一个单一子问题的代价，子问题对应某次递归调用。
2. 将树中每层代价求和，得到每层代价。
3. 将所有层代价求和，得到递归调用总代价。
- 适合用来生成好的猜测
#### 代入法
- 猜测解形式
- 用数学归纳法求出解中的常数
- 通常可以使用递归树猜测接的形式，使用代入法证明
#### 主方法

# 渐进记号
## Θ记号
- 对一个给定函数g(n)，用Θ(g(n))来表示以下函数的集合：
> **Θ(g(n)) = {f(n):存在正常量c1、c2和n0，使得对所有n>=n0，1 ≤ c1\*g(n) ≤ f(n) ≤ c2\*g(n)}**。
- g(n)是f(n)的一个渐进紧确界。
## Ο记号
- 用Ο(g(n))(大Οg(n))来表示以下函数的集合：
> **Ο(g(n)) = {f(n):存在正常量c和n0，使得对所有n>=n0，1 ≤ f(n) ≤ c\*g(n)}**。
- g(n)是f(n)的一个渐进上界。
## Ω记号
表示渐进下界

# 排序和顺序统计量
## 堆排序
## 快速排序
## 线性时间排序
## 中位数和顺序统计量